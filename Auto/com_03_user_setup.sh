#!/usr/bin/env bash
# (гарантирует, что скрипт запускается под bash, который будет найден через env в $PATH)
#
# user_setup.sh — автоматизация задания «LVM для PostgreSQL +-расширение root +-snapshot demo»
# 1. разрешение sudo-правила для группы wheel
# 2. создание группы guest
# 3. создание пользователей в цикле, добавляя их в выбранную группу: wheel или guest
#
# !Запускать от root:  sudo ./add_wheel_users.sh

set -e # при любой ошибке, т.е. нунулевой код возврата, скрипт будет прерван

# ──────────────────────────────
# Шаг -1. Требования запустить от root
# ──────────────────────────────
# Проверяем, запущен ли скрипт с привилегиями суперпользователя (sudo)
    # $EUID    — переменная Bash, содеражит UID текущего процесса
    # $EUID    — вернет 0, если script запущен от sudo
    # -ne 0    — оператор “not equal”. Проверяет, что значение слева не равно 0
    # [[ … ]]  — внутри выражение проверяется на истинность. Код = 0, если истина. Код = 1, если ложь.
    # [[ $EUID -ne 0 ]] — истина, если текущий UID не 0 (то есть не запущено под sudo)
    # если не равно 0, то выведется сообщение и script завершится с кодом 1
if [[ $EUID -ne 0 ]]; then
  echo "Запустите скрипт от root!"
  exit 1
fi

# ──────────────────────────────
# Шаг 0. Подготовка
# ──────────────────────────────
# 0.1. включаем правило для wheel в sudoers (с паролем)
    # grep:
    #   grep ищет в файле /etc/soduers строку, соответствующую регулярному выражению
    #   grep производит поиск, вызывается с ключами:
    #      -E включить расширенный синтаксис регулярных выражений
    #      -q "queit", т.е. ничего не выводит кроме кода возврата (0 - не найдено, 1 - найдено)
    #
    # Рег. выр.'^[[:space:]]*%wheel[[:space:]]+ALL'  :
    #   ' ' - в кавычки включается регулярное выражение
    #   Описание:
    #     1. ^ - якорь "начало строки", т.е. совпадения должны начаться с самого начала строки
    #     2. [[:space:]] - класс символов "пробельный символ", т.е. пробел, табуляция (\t), \n
    #        [[:space:]]*, где * - квантификатор (0 или более),
    #         т.е. нам подходит строка с >= 0 пробельными символами
    #     3. %wheel - ищем совпадение литерального текста
    #     4. [[:space:]]+, где + - квантификатор (1 или более)
    #     5. ALL - ищем совпадение литерального текста
    #   Итого ищем строки наподобие:
    #     1. %wheel ALL=(ALL) ALL
    #     2.     %wheel    ALL
    #
    # if ! grep - заходим в блок then, если НЕ НАШЛИ ПОДХОДЯЩИХ строка
    #
    # sed -i 's/^[#[:space:]]*\(%wheel[[:space:]].*ALL\)/\1/' /etc/sudoers
    #   >> sed -i
    #       sed - stream editor, утилита для построчной обработки текста
    #       -i - ключ для внесения изменения в файл, сохраняя изменный файл вместо оригинала
    #   >> s/<то, что хотим заменить>/<заменяем на это>/
    #       /<то, что хотим заменить>:
    #         1. ^[#[:space:]]* - найти от начала строки все символы # и "пробельные символы"
    #         2. \(%wheel[[:space:]].*ALL\) = \(...\) - захватить всё, что идет дальше
    #       /<заменяем на это>:
    #         1. /\1/, где \1 - замена, \1 значит вставить текст, который бый пойман первой группой
    #   >> sed:
    #      Находит совпадение с шаблоном и запоминает в «группе 1» нужную часть строки.
    #      Заменяет всю найденную подстроку на то, что было в группе 1 (\1), фактически удаляя всё,
    #      что было до и после самой группы (в данном случае — убирая # и лишние пробелы перед %wheel).
    #
    # блок then:
    #    >> будет выведено сообщение, что теперь правило активировано
    #    >> иначе выведено сообщение, что правило уже было активно
if ! grep -Eq '^[[:space:]]*%wheel[[:space:]]+ALL' /etc/sudoers ; then
  sed -i 's/^[#[:space:]]*\(%wheel[[:space:]].*ALL\)/\1/' /etc/sudoers
  echo "[INFO] Разрешение sudo для группы wheel активировано."
else
  echo "[INFO] Разрешение sudo для группы wheel уже существует."
fi

# 0.2. создаём группу guest, если её нет
    # if ...
    #   >> getent group guest - проверка наличия группы
    #   >> >/dev/null - перенаправляет вывод команды (текст) getent в мусор, не вляиет на код возврата
    #   >> getent возврает 0, если группа существует. Возвращает 2, если запись не найдена.
    #   >> ! инверсия кода возврата
    # then
    #   >> выполнится, если запись не найдена
    #   >> groupadd guest - если в системе нет группы guest, создаётся группа
    #   >> выведем информационное сообщение

if ! getent group guest >/dev/null ; then
  groupadd guest
  echo "[INFO] Группа guest создана."
fi

# переменные-массивы, в которые будут помещаться новые созданные пользователи
wheel_users=()   # для итогового отчёта
guest_users=()

# ──────────────────────────────
# Шаг 1. Интерактивный цикл по созданию пользователе
# Вводим админом по одному имени за раз, выбираем для него роль.
# Происходит:
# 1. Проверка существования учетки
# 2. Создание учетки (с домашней папкой и оболочкой)
# 3. Запрос и установка пароля для учетки
# 4. Добавление учетки в нужную группу (wheel или guest)
# ──────────────────────────────
while true; do
    # read - чтение одной строки из стандартного ввода
    #   -r - ключ для отключения специальной обработки обратного слэша (\)
    #   -p - ключ, чтобы не переходить на новую строку после вывода " теста "
    #   " наш текст " - формально называется приглашением
    #   ans - имя переменной, в которую будет записан введённый ответ
    #
    # ans=$(tr '[:upper:]' '[:lower:]' <<<"$ans")
    #   tr '[:upper:]' '[:lower:]' - замена всех заглавных букв на строчные
    #   <<<"$ans" - подача содержимого пееременной ans в tr
    #
    # [[ $ans =~ ^(н|n)$ ]] && break - если ответ ans 'n' или 'н', то выход из цикла while
    #   && - логическое И, правая часть break будет выполнена, если левая часть вернула 0
    #   $ans =~ ^(н|n)$ - проверка, что ans соответствует рег. выр ^(н|n)$
    #     =~ - оператор проверки сооответствия регулярному выражению
    #     ^ - начало строки
    #     (д|y) - группа альтернатив, которые нам удовлетворяют
    #     $ - конец строки
    #
    # [[ $ans =~ ^(д|y)$ ]] || { echo "Введите 'д' или 'н'"; continue; }
    #   если ответ ans НЕ 'д' или 'y', то выведем подсказку, что нужно вводить
    #   начнем цикл создания пользователя заново
  read -r -p "Добавить пользователя? [д/y | н/n]: " ans
  ans=$(tr '[:upper:]' '[:lower:]' <<<"$ans")
  [[ $ans =~ ^(н|n)$ ]] && break
  [[ $ans =~ ^(д|y)$ ]] || { echo "Введите 'д' или 'н'"; continue; }

  # 1. выбор роли
    # код аналогичен
  read -r -p "Тип пользователя: wheel(w) / guest(g): " role
  role=$(tr '[:upper:]' '[:lower:]' <<<"$role")
  [[ $role =~ ^(w|g)$ ]] || { echo "Введите 'w' или 'g'"; continue; }

  # 2. имя пользователя
    # -z - оператор проверки. Возвращает 0, если длина строки равна 0.
    # Если введенное имя пользователя равно 0, то выведем сообщение.
    # Остальной код аналогичен
  read -r -p "Имя пользователя: " user
  [[ -z $user ]] && { echo "Имя не может быть пустым."; continue; }

  # 3. создание или проверка существования
    # 3.1. Проверка существования пользователя
      # id "$user"             — проверяет, есть ли пользователь в системе
      # &>/dev/null             — подавляет любой вывод
      # если код возврата 0 -> пользователь есть -> выполняем блок then
      # иначе код ≠ 0 -> пользователь отсутствует -> переходим в блок else
  if id "$user" &>/dev/null ; then
    echo "[INFO] $user уже существует."
  else
    # 3.2. Создание пользователя
      # useradd             — утилита для добавления учётной записи
      # -m                  — создать домашнюю директорию /home/$user
      # -s /bin/bash        — назначить Bash оболочкой по умолчанию
      # "$user"             — имя создаваемого пользователя
    useradd -m -s /bin/bash "$user"
    # 3.2. Установка пароля
      #   read -r            — не интерпретировать слэши (\)
      #   -s                 — не отображать вводимые символы
      #   -p "…"             — вывести подсказку без переноса строки
      #   p1                 — переменная для первого ввода пароля
    while true; do
      read -rs -p "Пароль для $user: " p1; echo
      read -rs -p "Повторите пароль: " p2; echo # Повторный ввод пароля для подтверждения
        # Проверка совпадения и ненулевой длины:
        #   $p1 == "$p2"       — оба ввода совпадают
        #   -n $p1             — пароль не пустой
        # если оба истинны -> break (выход из цикла), иначе — сообщение и повтор
      [[ $p1 == "$p2" && -n $p1 ]] && break
      echo "Пароли не совпали, попробуйте ещё раз."
    done

    # 3.4. Установка пароля и очистка
      # echo "$user:$p1"  — формируем строку "логин:пароль"
      # | chpasswd        — передаём в chpasswd для безопасной установки
    echo "$user:$p1" | chpasswd
      # Удаляем переменные с паролями из окружения
    unset p1 p2
    echo "[INFO] Пользователь $user создан."
  fi

  # 4. включаем в нужную группу
  case $role in
    w)
        # usermod -aG wheel "$user"
          # -aG wheel    — добавить (-a) пользователя в дополнительную группу wheel (сохранив существующие)
          # "$user"      — логин пользователя для добавления
      usermod -aG wheel "$user"
        # wheel_users+=("$user") — добавить имя пользователя в массив wheel_users для итогового отчёта
      wheel_users+=("$user")
      echo "[INFO] $user добавлен в группу wheel."
      ;;
    g)
        # аналогично, но для группы guest
      usermod -aG guest "$user"
      guest_users+=("$user")
      echo "[INFO] $user добавлен в группу guest."
      ;;
  esac
done

# ──────────────────────────────
# 2. Итоговый отчёт: кто создан
# ──────────────────────────────
  # Проверяем, есть ли новые пользователи в массиве wheel_users
  #   ${#wheel_users[@]} — количество элементов в массиве wheel_users
  #   -gt 0              — больше 0?
  # Если да — выводим список через ${wheel_users[*]} (все элементы)
[[ ${#wheel_users[@]} -gt 0 ]] && echo "new wheel-пользователи: ${wheel_users[*]}"
  # Аналогично для массива guest_users
[[ ${#guest_users[@]} -gt 0 ]]  && echo "new guest-пользователи: ${guest_users[*]}"
  # Если ни в одном массиве нет новых пользователей
  #   -eq 0 — ровно 0 элементов
  # Используем логическое И `&&`: обе проверки должны быть истинны
  # Объединяем строки через `&& \` для читаемости
[[ ${#wheel_users[@]} -eq 0 && ${#guest_users[@]} -eq 0 ]] && \
  echo "Новые аккаунты не созданы."


# ──────────────────────────────
# 3. Статус: кто существует теперь (уже созданные и только что созданные пользователи)
# ──────────────────────────────

  # 3.1. Задаём массив групп для проверки
    # groups — массив имён групп, которые нужно обработать
groups=("wheel" "guest")

  # 3.2. Перебираем каждую группу из массива
for group in "${groups[@]}"; do
    # 3.2.1. Получаем список участников группы
      # getent group "$group" — извлекает строку из /etc/group
      # cut -d: -f4           — берёт 4-е поле (`members`), список через запятую
  members=$(getent group "$group" | cut -d: -f4)

    # 3.3. Проверка: есть ли вообще участники
      # [[ -z "$members" ]] — истина, если переменная members пуста (нет участников)
  if [[ -z "$members" ]]; then
    echo "Группа '$group' не имеет участников."
  else
      # 3.4. Выводим заголовок и каждого пользователя по-отдельности
    echo "Пользователи группы '$group':"
      # 3.4.1. Разбиваем строку members по запятым в массив arr
        # IFS=','            — временно меняем разделитель на запятую
        # read -ra arr <<<…   — читаем в массив arr, опуская кавычки
    IFS=',' read -ra arr <<< "$members"
      # 3.4.2. Перебираем массив и выводим имена с отступом
    for user in "${arr[@]}"; do
      echo "  - $user"
    done
  fi
  echo # добавление пустой строки
done
